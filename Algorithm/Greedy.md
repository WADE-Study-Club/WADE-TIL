# Greedy

`Greedy`를 이용해 문제를 푸는게 가장 **최적의 해**를 보장한다는 것을 증명 할 수 있어야 한다.

### 그리디 알고리즘을 이용해 문제를 풀 수 있는 케이스

1. 거스름돈

   - 가장 큰 화폐 단위부터 돈을 거슬러준다.
   - 이때, 큰 화폐 단위는 무조건 작은 화폐단위의 배수이기 때문에 항상 **최적의 해를 보장**한다.
     ex) 800원을 거슬러 줘야하는데 화폐단위가 500, 400, 100이면 최적의 해를 보장하지 못함 → 이경우, `DB` 를 이용한다.
   - 시간 복잡도 : 금액과는 무관하며 화폐의 종류에 영향을 받음
     화폐의 종류가 K라고 할 때, 소스코드의 시간 복잡도는 0(K)이다.

2. 1이 될 때까지

   - 어떠한 수 N이 1이 될 때까지 다음 두 과정 중 하나를 반복적으로 선택하여 수행하려고하 한다. 단, 두번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있다.
     ```
     1. N에서 1을 뺀다.
     2. N을 K로 나눈다.
     ```
   - 주어진 N에 대하여 **최대한 많이 나누기**를 수행한다.
   - K가 2 이상이기만 하면, K로 나누는 것이 1을 빼는 것보다 항상 N을 줄일 수 있다.(**최적의 해 성립**)

   ```python
   n, k = map(int, input().split())
   result = 0

   while True:
   	target = (n // k) * k
   	result += (n - target)
   	n = target

   	if n < k :
   		break

   	result += 1
   	n //= k

   result += (n - 1)
   print(result)
   ```

3. 곱하기 혹은 더하기

   - 각 자리 숫자(0부터 9)로만 이루어진 문자열 S가 주어졌을 때, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 'x' 혹은 '+' 연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성해라. 단, 모든 연산은 '+', 'x'와 상관 없이 왼쪽에서 부터 순서대로 이루어진다.
   - 예를 들어 02984라는 문자열로 만들 수 있는 가장 큰 수는 ((((0 + 2) x 9) x 8) x 4) = 576 이다.
   - 이때, '0' 혹은 '1'인 경우는 더하기, 나머지는 곱한다.

   ```python
   data = input()
   result = int(data[0])

   for i in range(i,len(data)):
   	num = int(data[i])
   	if num <= 1 or result <= 1:
   		result += num
   	else:
   		result *= num

   print(result)
   ```
